C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Program Files\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "STC15F2K.h"
   2          #include "intrins.h"
   3          #include <math.h>
   4          
   5          #define uchar unsigned char  //无符号字符型 宏定义  变量范围0~255
   6          #define uint  unsigned int   //无符号整型 宏定义  变量范围0~65535
   7          #define ADC_POWER   0x80            //ADC电源控制位
   8          #define ADC_FLAG    0x10            //ADC完成标志
   9          #define ADC_START   0x08            //ADC起始控制位
  10          #define ADC_SPEEDLL 0x00            //540个时钟
  11          #define ADC_SPEEDL  0x20            //360个时钟
  12          #define ADC_SPEEDH  0x40            //180个时钟
  13          #define ADC_SPEEDHH 0x60            //90个时钟
  14          
  15          sfr ADC_LOW2    =   0xBE;           //ADC低2位结果
  16          
  17          bit nx;
  18          bit sw;
  19          bit nx=0;
  20          bit sw=0; //温度时间切换
  21          
  22          sbit clk = P3^2;    //ds1302时钟线定义      15W408AS
  23          sbit io =  P5^5;    //数据线
  24          sbit rst = P5^4;    //复位线
  25          sbit DS4=P3^4;
  26          sbit DS3=P3^5;
  27          sbit DS2=P3^6;
  28          sbit DS1=P3^7;
  29          sbit sw1=P3^0;
  30          sbit sw2=P3^1;
  31          
  32          //                      秒    分  时    日    月  年  星期
  33          uchar code init_ds[]  ={0x00,0x00,0x00,0x01,0x01,0x00,0x13}; 
  34          uchar code write_add[]={0x80,0x82,0x84};   //写地址,0x86,0x88,0x8c,0x8a
  35          uchar code read_add[] ={0x81,0x83,0x85};   //读地址,0x87,0x89,0x8d,0x8b 
  36          uchar dat1[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xf8,0X80,0X90,0xff,0xc6};//正立无小数点
  37          uchar dat2[]={0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0X00,0X10,0xff};//正立有小数点
  38          uchar dat3[]={0x40,0x4F,0x24,0x06,0x0B,0x12,0x10,0x47,0X00,0X02,0xff};//倒立有小数点
  39          uchar dat4[]={0xC0,0xCF,0xA4,0x86,0x8B,0x92,0x90,0xC7,0X80,0X82,0xff};//倒立无小数点
  40          uchar Differ_Time=0;//不同数字所需要延时时间
  41          uchar table[4]={0};
  42          uchar nk=0;
  43          uchar gk=0;
  44          uchar menu;
  45          uchar i=0;
  46          uchar point_display=0;
  47          
  48          uint tem=0,lum=0;
  49          uint ld;
  50          uint fen;
  51          uint shi;
  52          uint miao;
  53          uint nfen;
  54          uint nshi;
  55          uint fen,shi,miao;//,ri,yue,week,nian=0x20;
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 2   

  56          uint nfen=0;
  57          uint nshi=0;
  58          uint is_not_display_tem=0;
  59          uint is_not_display_lum=0;
  60          uint is_not_collect=0;
  61          uint two_point_flag=0;
  62          uint cycle_display_flag=0;
  63          uint AD_collect_flag=0;
  64          
  65          void Delayms(uint t)
  66          {
  67   1        uchar i;
  68   1        while(t--)
  69   1          for(i=0;i<123;i++);
  70   1      }
  71          
  72          void Delay_select(uchar i)
  73          {
  74   1        switch(i)
  75   1        {
  76   2          case 0:Differ_Time=5;break;
  77   2          case 1:Differ_Time=2;break;
  78   2          case 2:Differ_Time=5;break;
  79   2          case 3:Differ_Time=5;break;
  80   2          case 4:Differ_Time=4;break;
  81   2          case 5:Differ_Time=5;break;
  82   2          case 6:Differ_Time=5;break;
  83   2          case 7:Differ_Time=3;break;
  84   2          case 8:Differ_Time=5;break;
  85   2          case 9:Differ_Time=5;break;
  86   2          default:break;
  87   2        }
  88   1      }
  89          
  90          void display(uint local,uint is_not_time)//local小数点位置,is_not_time是否是显示时间的格式
  91          {
  92   1        P2=0XFF;
  93   1        DS1=1;
  94   1        DS2=0;
  95   1        DS3=0;
  96   1        DS4=0;
  97   1        
  98   1        if(local==0)
  99   1        {
 100   2          P2=dat2[table[0]];
 101   2        }
 102   1        else
 103   1        {
 104   2          P2=dat1[table[0]];
 105   2        }
 106   1        Delay_select(table[0]);
 107   1        Delayms(Differ_Time);
 108   1      
 109   1        P2=0XFF;
 110   1        DS1=0;
 111   1        DS2=1;
 112   1        DS3=0;
 113   1        DS4=0;
 114   1        if(is_not_time==1)
 115   1        {
 116   2          if(point_display==1)
 117   2          {
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 3   

 118   3            P2=dat2[table[1]];
 119   3          }
 120   2          else if(point_display==0)
 121   2          {
 122   3            P2=dat1[table[1]];
 123   3          }
 124   2        }
 125   1        else if(is_not_time==0)
 126   1        {
 127   2          if(local==1)
 128   2          {
 129   3            P2=dat2[table[1]];
 130   3          }
 131   2          else
 132   2          {
 133   3            P2=dat1[table[1]];
 134   3          }
 135   2        }
 136   1        Delay_select(table[1]);
 137   1        Delayms(Differ_Time);
 138   1      
 139   1        P2=0XFF;
 140   1        DS1=0;
 141   1        DS2=0;
 142   1        DS3=1;
 143   1        DS4=0;
 144   1        //如果是显示时间，则第三个数码管一定要显示小数点，且小数点闪烁
 145   1        //如果不是显示时间，则根据需求显示
 146   1        if(is_not_time==1)
 147   1        {
 148   2          if(point_display==1)
 149   2          {
 150   3            P2=dat3[table[2]];
 151   3          }
 152   2          else if(point_display==0)
 153   2          {
 154   3            P2=dat4[table[2]];
 155   3          }
 156   2        }
 157   1        else if(is_not_time==0)
 158   1        {
 159   2          if(local==2)
 160   2          {
 161   3            P2=dat3[table[2]];
 162   3          }
 163   2          else
 164   2          {
 165   3            P2=dat4[table[2]];
 166   3          }
 167   2        }
 168   1        Delay_select(table[2]);
 169   1        Delayms(Differ_Time);
 170   1      
 171   1        P2=0XFF;
 172   1        DS1=0;
 173   1        DS2=0;
 174   1        DS3=0;
 175   1        DS4=1;
 176   1        if(local==3)
 177   1        {
 178   2          P2=dat2[table[3]];
 179   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 4   

 180   1        else
 181   1        {
 182   2          P2=dat1[table[3]];
 183   2        }
 184   1        Delay_select(table[3]);
 185   1        Delayms(Differ_Time);
 186   1      
 187   1        DS1=0;
 188   1        DS2=0;
 189   1        DS3=0;
 190   1        DS4=0;
 191   1      }
 192          
 193          /*************写一个数据到对应的地址里***************/
 194          void write_ds1302(uchar add,uchar dat)
 195          {
 196   1        uchar i;
 197   1        rst = 1;       //把复位线拿高
 198   1        for(i=0;i<8;i++)
 199   1        {            //低位在前
 200   2          clk = 0;     //时钟线拿低开始写数据
 201   2          io = add & 0x01;
 202   2          add >>= 1;     //把地址右移一位
 203   2          clk = 1;     //时钟线拿高
 204   2        } 
 205   1        for(i=0;i<8;i++)
 206   1        {
 207   2          clk = 0;     //时钟线拿低开始写数据
 208   2          io = dat & 0x01;
 209   2          dat >>= 1;     //把数据右移一位
 210   2          clk = 1;     //时钟线拿高
 211   2        }
 212   1        rst = 0;       //复位线合低
 213   1        clk = 0;
 214   1        io = 0;
 215   1      }
 216          
 217          /*************从对应的地址读一个数据出来***************/
 218          uchar read_ds1302(uchar add)
 219          {
 220   1        uchar value,i;
 221   1        rst = 1;       //把复位线拿高
 222   1        for(i=0;i<8;i++)
 223   1        {            //低位在前
 224   2          clk = 0;     //时钟线拿低开始写数据
 225   2          io = add & 0x01;      
 226   2          add >>= 1;     //把地址右移一位
 227   2          clk = 1;     //时钟线拿高
 228   2        }   
 229   1        for(i=0;i<8;i++)
 230   1        {
 231   2          clk = 0;     //时钟线拿低开始读数据
 232   2          value >>= 1;
 233   2          if(io == 1)
 234   2            value |= 0x80;
 235   2          clk = 1;     //时钟线拿高
 236   2        }
 237   1        rst = 0;       //复位线合低
 238   1        clk = 0;
 239   1        io = 0;
 240   1        return value;    //返回读出来的数据
 241   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 5   

 242          
 243          /*************把要的时间 年月日 都读出来***************/
 244          void read_time()
 245          {
 246   1      //  miao = read_ds1302(read_add[0]);  //读秒
 247   1      
 248   1        fen  = read_ds1302(0x83); //读分
 249   1        shi  = read_ds1302(0x85); //读时
 250   1      
 251   1      //  ri   = read_ds1302(read_add[3]);  //读日
 252   1      //  yue  = read_ds1302(read_add[4]);  //读月
 253   1      //  nian = read_ds1302(read_add[5]);  //读年
 254   1      //  week = read_ds1302(read_add[6]);  //读星期
 255   1      }
 256          
 257          /*************把要写的时间 年月日 都写入ds1302里***************/
 258          void write_time()
 259          {
 260   1        write_ds1302(0x8e,0x00);      //关闭写保护
 261   1      //  write_ds1302(write_add[0],miao);  //写秒
 262   1        write_ds1302(0x80,miao);    //写秒
 263   1        write_ds1302(0x82,fen);   //写分
 264   1        write_ds1302(0x84,shi);   //写时
 265   1      //  write_ds1302(write_add[3],ri);    //写日
 266   1      //  write_ds1302(write_add[4],yue);   //写月
 267   1      //  write_ds1302(write_add[5],nian);  //写年
 268   1      //  write_ds1302(write_add[6],week);  //写星期
 269   1      
 270   1        write_ds1302(0xc2,nshi);      //写时
 271   1        write_ds1302(0xc4,nfen);      //写分
 272   1      
 273   1        write_ds1302(0x8e,0x80);      //打开写保护
 274   1      }
 275          
 276          void write_setting()
 277          {
 278   1        write_ds1302(0x8e,0x00);
 279   1        write_ds1302(0xcc,sw);
 280   1        write_ds1302(0xca,nx);
 281   1        write_ds1302(0xc8,gk);
 282   1        write_ds1302(0xc6,nk);
 283   1        write_ds1302(0x8e,0x80);
 284   1      }
 285          
 286          void read_setting()
 287          {
 288   1        
 289   1        nk = read_ds1302(0xc7);         //          1100 0111 读取Ram3
 290   1        gk = read_ds1302(0xc9);         //          1100 1001 读取Ram4
 291   1        nx = read_ds1302(0xcb);
 292   1        sw = read_ds1302(0xcd);
 293   1      }
 294          
 295          /*************把数据保存到ds1302 RAM中**0-31*************/
 296          void write_ds1302ram(uchar add,uchar dat)
 297          {
 298   1        add <<= 1;     //地址是从第二位开始的
 299   1        add &= 0xfe;   //把最低位清零  是写的命令
 300   1        add |= 0xc0;   //地址最高两位为 1  
 301   1        write_ds1302(0x8e,0x00);
 302   1        write_ds1302(add,dat);  
 303   1        write_ds1302(0x8e,0x80);
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 6   

 304   1      }
 305          
 306          /*************把数据从ds1302 RAM读出来**0-31*************/
 307          uchar read_ds1302ram(uchar add)
 308          {
 309   1        add <<= 1;     //地址是从第二位开始的
 310   1        add |= 0x01;   //把最高位置1  是读命令
 311   1        add |= 0xc0;   //地址最高两位为 1  
 312   1        return(read_ds1302(add)); 
 313   1      }
 314          
 315          
 316          void GetADCResult(unsigned char ch,unsigned int *value)
 317          {
 318   1        ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ch | ADC_START;
 319   1        _nop_();                        //Must wait before inquiry
 320   1        _nop_();
 321   1        _nop_();
 322   1        _nop_();
 323   1        _nop_();                        //Must wait before inquiry
 324   1        _nop_();
 325   1        while(!(ADC_CONTR & ADC_FLAG));//Wait complete flag
 326   1        ADC_CONTR &= ~ADC_FLAG;         //Close ADC
 327   1        
 328   1        *value = 0;
 329   1        *value = ADC_RES;
 330   1        *value = ((*value)*4 + ADC_LOW2);   //Return ADC result.×￠êíμ?′????ò・μ??8??ADC?á1?
 331   1      }
 332          
 333          //收集温度和光强度
 334          void collect_tem_and_lum()
 335          {
 336   1        //允许采样
 337   1        if(is_not_collect==1)
 338   1        {
 339   2          is_not_collect=0;
 340   2          GetADCResult(2,&lum);   //光敏AD采样
 341   2          GetADCResult(3,&tem);   //热敏AD采样
 342   2          tem = (unsigned int) ( ( 3950.0 / ( 11.33657 + log( 6.04 * (float)tem / ( 1024.0 - (float)tem ) ) ) - 27
             -8.15) * 100 );
 343   2        }
 344   1        //光控制显示亮度
 345   1        ld=(lum/50)*8;
 346   1      }
 347          
 348          void choose_display(uchar choose)
 349          {
 350   1        if(choose == 't')
 351   1        {
 352   2          read_time();
 353   2      
 354   2          table[0]=shi/16;
 355   2          table[1]=shi%16;
 356   2          table[2]=fen/16;
 357   2          table[3]=fen%16;
 358   2      
 359   2          display(1,1);
 360   2          Delayms(ld);
 361   2        }
 362   1        else if(choose == 'T')
 363   1        {
 364   2          if(tem>=10)
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 7   

 365   2          {
 366   3            table[0]=tem/1000;
 367   3            table[1]=tem%1000/100;
 368   3            table[2]=tem%1000%100/10;
 369   3            table[3]=11;
 370   3          }
 371   2          else if(tem<10)
 372   2          {
 373   3            table[0]=tem%1000/100;
 374   3            table[1]=tem%1000%100/10;
 375   3            table[2]=tem%1000%100%10;
 376   3            table[3]=11;
 377   3          }
 378   2          display(1,0);
 379   2          Delayms(ld);
 380   2        }
 381   1        else if(choose == 'l')
 382   1        {
 383   2          table[0]=lum/1000;
 384   2          table[1]=lum%1000/100;
 385   2          table[2]=lum%1000%100/10;
 386   2          table[3]=lum%1000%100%10;
 387   2          display(3,0);
 388   2          Delayms(ld);
 389   2        }
 390   1      }
 391          
 392          void key()
 393          {
 394   1        if(sw1==0)
 395   1        {
 396   2          menu++;
 397   2          if(menu==6){menu=0;write_time();}
 398   2          while(sw1==0);//确保松手之前不变
 399   2        }
 400   1        
 401   1        //在时间显示页面，按下sw2就可以初始化时间
 402   1        if(menu==0 || menu==1)
 403   1        {
 404   2          if(sw2==0)
 405   2          {
 406   3            //init_ds1302
 407   3            /*************初始化ds1302时间***************/
 408   3            rst = 0;  //第一次读写数据时要把IO品拿低
 409   3            clk = 0;
 410   3            io = 0;
 411   3            i = read_ds1302ram(30);   
 412   3            if(i != 3)
 413   3            {
 414   4              i = 3;
 415   4              write_ds1302ram(30,i);
 416   4              write_ds1302(0x8e,0x00);  //关闭写保护
 417   4              for(i=0;i<3;i++)
 418   4                write_ds1302(write_add[i],init_ds[i]);  //把最高位值0 允许ds1302工作
 419   4              write_ds1302(0x8e,0x80);  //打开写保护
 420   4            }
 421   3            while(sw2==0);
 422   3          }
 423   2        }
 424   1        if(menu==4)
 425   1        {
 426   2          if(sw2==0)
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 8   

 427   2          {
 428   3            if(fen >= 0x59)fen=0;
 429   3            else fen=fen+0x01;
 430   3            if((fen & 0x0f) >= 0x0a)fen = (fen & 0xf0) + 0x10;
 431   3            while(sw2==0);
 432   3            miao=0;//秒钟归零
 433   3          }
 434   2        }
 435   1        if(menu==5)
 436   1        {
 437   2          if(sw2==0)
 438   2          {
 439   3            shi+=0x01;
 440   3            if((shi & 0x0f) >= 0x0a)shi = (shi & 0xf0) + 0x10;
 441   3            if(shi >= 0x24)shi = 0;
 442   3            while(sw2==0);
 443   3            miao=0;//秒钟归零
 444   3          }
 445   2        }
 446   1        write_setting();   //断电保存
 447   1      }
 448          
 449          void init()
 450          {
 451   1        uchar i;
 452   1        
 453   1        //init
 454   1        TMOD= 0x01;
 455   1        TL0 = (65536-50000)/256;        //设置定时初值
 456   1        TH0 = (65536-50000)%256;        //设置定时初值
 457   1        ET0 = 1;
 458   1        TR0 = 1;
 459   1        EA = 1;
 460   1        
 461   1        //InitADC
 462   1        P1ASF = 0x7f;                 //Open channels ADC function 0100 0000 p1.6使用AD功能
 463   1        ADC_RES  = 0;                       //Clear previous result
 464   1        ADC_LOW2 = 0;
 465   1        ADC_CONTR = ADC_POWER | ADC_SPEEDLL;
 466   1        
 467   1        //init_ds1302_io
 468   1        rst = 0;  //第一次读写数据时要把IO品拿低
 469   1        clk = 0;
 470   1        io = 0;
 471   1        
 472   1        //init_ds1302
 473   1        /*************初始化ds1302时间***************/
 474   1        rst = 0;  //第一次读写数据时要把IO品拿低
 475   1        clk = 0;
 476   1        io = 0;
 477   1        i = read_ds1302ram(30);   
 478   1        if(i != 3)
 479   1        {
 480   2          i = 3;
 481   2          write_ds1302ram(30,i);
 482   2          write_ds1302(0x8e,0x00);  //关闭写保护
 483   2          for(i=0;i<3;i++)
 484   2            write_ds1302(write_add[i],init_ds[i]);  //把最高位值0 允许ds1302工作
 485   2          write_ds1302(0x8e,0x80);  //打开写保护
 486   2        }
 487   1      }
 488          
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 9   

 489          void main()
 490          {
 491   1        P2M0=0xFF;
 492   1        P2M1=0x00;
 493   1      
 494   1        P3M0 = 0xF0;
 495   1        P3M1 = 0x00;
 496   1      
 497   1        init();
 498   1        
 499   1        read_setting();
 500   1        
 501   1        while(1)
 502   1        {
 503   2          key();
 504   2          collect_tem_and_lum();
 505   2          //菜单一循环显示
 506   2          //菜单二只显示时间
 507   2          //菜单三只显示温度
 508   2          //菜单四只显示光强度
 509   2          //菜单五调整时
 510   2          //菜单六调整分
 511   2          if(menu==0)
 512   2          {
 513   3            if(is_not_display_tem==1)choose_display('T');      //一定条件下显示温度
 514   3            else if(is_not_display_lum==1)choose_display('l'); //一定条件下显示发光强度
 515   3            else choose_display('t'); //其他条件下显示时间
 516   3          }
 517   2          if(menu==1)choose_display('t');//只显示时间
 518   2          if(menu==2)choose_display('T');//只显示温度
 519   2          if(menu==3)choose_display('l');//只显示光强
 520   2          //调整时
 521   2          if(menu==4)
 522   2          {
 523   3            //闪烁
 524   3            if(point_display>0)
 525   3            {
 526   4              table[2]=fen/16;
 527   4              table[3]=fen%16;
 528   4            }
 529   3            else
 530   3            {
 531   4              table[2]=10;
 532   4              table[3]=10;
 533   4            }
 534   3            table[0]=shi/16;
 535   3            table[1]=shi%16;
 536   3            choose_display('t');
 537   3          }
 538   2          //调整分
 539   2          if(menu==5)
 540   2          {
 541   3            table[2]=fen/16;
 542   3            table[3]=fen%16;
 543   3            //闪烁
 544   3            if(point_display>0)
 545   3            {
 546   4              table[0]=shi/16;
 547   4              table[1]=shi%16;
 548   4            }
 549   3            else
 550   3            {
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 10  

 551   4              table[0]=10;
 552   4              table[1]=10;
 553   4            }
 554   3            choose_display('t');
 555   3          }
 556   2        }
 557   1      }
 558          
 559          void InitTimer1() interrupt 1  // 1毫秒@11.0592MHz
 560          {
 561   1        TL0 = (65536-50000)/256;        //设置定时初值
 562   1        TH0 = (65536-50000)%256;        //设置定时初值
 563   1        
 564   1        two_point_flag++;
 565   1        cycle_display_flag++;
 566   1        AD_collect_flag++;
 567   1        
 568   1        //定时采样光敏和热敏AD采样flag
 569   1        if(AD_collect_flag>20)
 570   1        {
 571   2          AD_collect_flag=0;
 572   2          is_not_collect=1;
 573   2        }
 574   1        
 575   1        //时钟中间两点闪烁及选择闪烁flag
 576   1        if(two_point_flag==30)
 577   1        {
 578   2          two_point_flag=0;
 579   2          point_display=!point_display;//时钟中间两点闪烁及选择闪烁标志位
 580   2        }
 581   1        
 582   1        //菜单一循环显示flag
 583   1        if(cycle_display_flag>0 && cycle_display_flag<300)
 584   1        {
 585   2          is_not_display_tem=0;
 586   2          is_not_display_lum=0;
 587   2        }
 588   1        if(cycle_display_flag>300 && cycle_display_flag<500)
 589   1        {
 590   2          is_not_display_tem=1;
 591   2          is_not_display_lum=0;
 592   2        }
 593   1        if(cycle_display_flag>500 && cycle_display_flag<700)
 594   1        {
 595   2          is_not_display_tem=0;
 596   2          is_not_display_lum=1;
 597   2        }
 598   1        if(cycle_display_flag>700)
 599   1        {
 600   2          cycle_display_flag=0;//重新开始
 601   2        }
 602   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1843    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     83       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
C51 COMPILER V9.59.0.0   MAIN                                                              12/25/2022 17:26:32 PAGE 11  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
